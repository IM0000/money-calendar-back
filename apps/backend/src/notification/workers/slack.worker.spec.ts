import { Test, TestingModule } from '@nestjs/testing';
import { Job } from 'bull';
import { SlackWorker } from './slack.worker';
import { SlackService } from '../../slack/slack.service';
import { NotificationDeliveryService } from '../notification-delivery.service';
import { buildNotificationMessages } from '../message-builders';
import { ContentType, NotificationType } from '@prisma/client';

// Message builder Mock
jest.mock('../message-builders', () => ({
  buildNotificationMessages: jest.fn(),
}));

describe('SlackWorker', () => {
  let worker: SlackWorker;
  let slackService: SlackService;
  let deliveryService: NotificationDeliveryService;

  const mockSlackService = {
    sendNotificationMessage: jest.fn(),
  };

  const mockDeliveryService = {
    findById: jest.fn(),
    updateToSent: jest.fn(),
    updateToFailed: jest.fn(),
  };

  const mockBuildNotificationMessages =
    buildNotificationMessages as jest.MockedFunction<
      typeof buildNotificationMessages
    >;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SlackWorker,
        {
          provide: SlackService,
          useValue: mockSlackService,
        },
        {
          provide: NotificationDeliveryService,
          useValue: mockDeliveryService,
        },
      ],
    }).compile();

    worker = module.get<SlackWorker>(SlackWorker);
    slackService = module.get<SlackService>(SlackService);
    deliveryService = module.get<NotificationDeliveryService>(
      NotificationDeliveryService,
    );
  });

  afterEach(() => {
    jest.clearAllMocks();
    // Í∏∞Î≥∏ Mock ÏÑ§Ï†ï
    mockDeliveryService.findById.mockResolvedValue({
      id: 2,
      status: 'PENDING',
      retryCount: 0,
    });
  });

  describe('handleSlackNotification', () => {
    const mockJobData = {
      deliveryId: 2,
      notificationId: 123,
      userId: 456,
      userEmail: 'test@example.com',
      contentType: ContentType.EARNINGS,
      contentId: 789,
      notificationType: NotificationType.DATA_CHANGED,
      currentData: { actualEPS: '1.25', actualRevenue: '500M' },
      previousData: { actualEPS: '1.10', actualRevenue: '480M' },
      userSettings: {
        emailEnabled: false,
        slackEnabled: true,
        slackWebhookUrl: 'https://hooks.slack.com/services/test/webhook',
        notificationsEnabled: true,
      },
    };

    const mockJob = {
      data: mockJobData,
      id: 'slack-job-1',
      attemptsMade: 1,
    } as Job;

    const mockSlackMessage = {
      text: 'üè¢ *Apple (AAPL)* Ïã§Ï†ÅÏù¥ ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§!\n\nüìä *EPS*: $1.10 ‚Üí $1.25\nüí∞ *Îß§Ï∂ú*: $480M ‚Üí $500M',
    };

    it('Ïä¨Îûô Î©îÏãúÏßÄ Ï†ÑÏÜ°Ïù¥ ÏÑ±Í≥µÌïòÎ©¥ ÏÉÅÌÉúÎ•º SENTÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Ìï¥Ïïº ÌïúÎã§', async () => {
      // Mock ÏÑ§Ï†ï
      mockBuildNotificationMessages.mockReturnValue({
        email: { subject: 'test', html: 'test' },
        slack: mockSlackMessage,
      });

      mockSlackService.sendNotificationMessage.mockResolvedValue(undefined);

      // Ïã§Ìñâ
      await worker.handleSlackNotification(mockJob);

      // Í≤ÄÏ¶ù
      expect(mockBuildNotificationMessages).toHaveBeenCalledWith({
        contentType: ContentType.EARNINGS,
        notificationType: NotificationType.DATA_CHANGED,
        currentData: mockJobData.currentData,
        previousData: mockJobData.previousData,
        userId: 456,
      });

      expect(mockSlackService.sendNotificationMessage).toHaveBeenCalledWith({
        webhookUrl: 'https://hooks.slack.com/services/test/webhook',
        text: mockSlackMessage.text,
      });

      expect(mockDeliveryService.updateToSent).toHaveBeenCalledWith(
        2,
        expect.any(Number), // processingTime
      );

      expect(mockDeliveryService.updateToFailed).not.toHaveBeenCalled();
    });

    it('Ïä¨Îûô Î©îÏãúÏßÄ Ï†ÑÏÜ°Ïù¥ Ïã§Ìå®ÌïòÎ©¥ ÏÉÅÌÉúÎ•º FAILEDÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÌïòÍ≥† ÏóêÎü¨Î•º Îã§Ïãú ÎçòÏ†∏Ïïº ÌïúÎã§', async () => {
      // Mock ÏÑ§Ï†ï
      const testError = new Error('Slack webhook failed');

      mockBuildNotificationMessages.mockReturnValue({
        email: { subject: 'test', html: 'test' },
        slack: mockSlackMessage,
      });

      mockSlackService.sendNotificationMessage.mockRejectedValue(testError);

      // Ïã§Ìñâ Î∞è Í≤ÄÏ¶ù
      await expect(worker.handleSlackNotification(mockJob)).rejects.toThrow(
        'Slack webhook failed',
      );

      expect(mockDeliveryService.updateToFailed).toHaveBeenCalledWith(
        2,
        1, // newRetryCount (delivery.retryCount + 1)
        testError, // Error Í∞ùÏ≤¥
        expect.any(Number), // processingTime
      );

      expect(mockDeliveryService.updateToSent).not.toHaveBeenCalled();
    });

    it('Slack rate limit ÏóêÎü¨Î•º Ïò¨Î∞îÎ•¥Í≤å Ï≤òÎ¶¨Ìï¥Ïïº ÌïúÎã§', async () => {
      // Mock ÏÑ§Ï†ï
      const rateLimitError = new Error('rate_limited');

      mockBuildNotificationMessages.mockReturnValue({
        email: { subject: 'test', html: 'test' },
        slack: mockSlackMessage,
      });

      mockSlackService.sendNotificationMessage.mockRejectedValue(
        rateLimitError,
      );

      // Ïã§Ìñâ Î∞è Í≤ÄÏ¶ù
      await expect(worker.handleSlackNotification(mockJob)).rejects.toThrow(
        'rate_limited',
      );

      expect(mockDeliveryService.updateToFailed).toHaveBeenCalledWith(
        2,
        1,
        rateLimitError, // Error Í∞ùÏ≤¥
        expect.any(Number),
      );
    });

    it('Slack webhook URL Î¨¥Ìö® ÏóêÎü¨Î•º Ïò¨Î∞îÎ•¥Í≤å Ï≤òÎ¶¨Ìï¥Ïïº ÌïúÎã§', async () => {
      // Mock ÏÑ§Ï†ï
      const invalidUrlError = new Error('invalid_payload');

      mockBuildNotificationMessages.mockReturnValue({
        email: { subject: 'test', html: 'test' },
        slack: mockSlackMessage,
      });

      mockSlackService.sendNotificationMessage.mockRejectedValue(
        invalidUrlError,
      );

      // Ïã§Ìñâ Î∞è Í≤ÄÏ¶ù
      await expect(worker.handleSlackNotification(mockJob)).rejects.toThrow(
        'invalid_payload',
      );

      expect(mockDeliveryService.updateToFailed).toHaveBeenCalledWith(
        2,
        1,
        invalidUrlError, // Error Í∞ùÏ≤¥
        expect.any(Number),
      );
    });

    it('Î©îÏãúÏßÄ ÎπåÎçîÍ∞Ä Ïã§Ìå®ÌïòÎ©¥ ÏóêÎü¨Î•º Ï≤òÎ¶¨Ìï¥Ïïº ÌïúÎã§', async () => {
      // Mock ÏÑ§Ï†ï
      const builderError = new Error('Î©îÏãúÏßÄ ÎπåÎçî Ïã§Ìå®');
      mockBuildNotificationMessages.mockImplementation(() => {
        throw builderError;
      });

      // Ïã§Ìñâ Î∞è Í≤ÄÏ¶ù
      await expect(worker.handleSlackNotification(mockJob)).rejects.toThrow(
        'Î©îÏãúÏßÄ ÎπåÎçî Ïã§Ìå®',
      );

      expect(mockSlackService.sendNotificationMessage).not.toHaveBeenCalled();
      expect(mockDeliveryService.updateToFailed).toHaveBeenCalledWith(
        2,
        1,
        builderError, // Error Í∞ùÏ≤¥
        expect.any(Number),
      );
    });

    it('Ïã§Ï†Å ÏïåÎ¶º Î©îÏãúÏßÄÎ•º Ïò¨Î∞îÎ•¥Í≤å Ï≤òÎ¶¨Ìï¥Ïïº ÌïúÎã§', async () => {
      const earningsJobData = {
        ...mockJobData,
        contentType: ContentType.EARNINGS,
        currentData: {
          actualEPS: '1.25',
          actualRevenue: '500M',
          company: { name: 'Apple', ticker: 'AAPL' },
        },
        previousData: {
          actualEPS: '1.10',
          actualRevenue: '480M',
          company: { name: 'Apple', ticker: 'AAPL' },
        },
      };

      const earningsJob = { ...mockJob, data: earningsJobData } as Job;

      // Ïã§Ï†ú Î©îÏãúÏßÄ ÎπåÎçîÎ•º Ìò∏Ï∂úÌïòÏó¨ ÏòàÏÉÅ Î©îÏãúÏßÄ ÏÉùÏÑ±
      const { buildNotificationMessages: actualBuilder } = jest.requireActual(
        '../message-builders',
      );
      const expectedMessages = actualBuilder({
        contentType: ContentType.EARNINGS,
        notificationType: NotificationType.DATA_CHANGED,
        currentData: earningsJobData.currentData,
        previousData: earningsJobData.previousData,
        userId: 456,
      });

      // Mock ÏÑ§Ï†ï - Ïã§Ï†ú Î©îÏãúÏßÄ ÎπåÎçî Í≤∞Í≥º ÏÇ¨Ïö©
      mockBuildNotificationMessages.mockReturnValue(expectedMessages);

      mockSlackService.sendNotificationMessage.mockResolvedValue(undefined);

      // Ïã§Ìñâ
      await worker.handleSlackNotification(earningsJob);

      // Í≤ÄÏ¶ù - Ïã§Ï†ú ÏÉùÏÑ±Îêú Î©îÏãúÏßÄÍ∞Ä SlackServiceÎ°ú Ï†ÑÎã¨ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      expect(mockSlackService.sendNotificationMessage).toHaveBeenCalledWith({
        webhookUrl: 'https://hooks.slack.com/services/test/webhook',
        text: expectedMessages.slack.text,
        blocks: expectedMessages.slack.blocks,
      });

      // Î©îÏãúÏßÄ ÎÇ¥Ïö© Í≤ÄÏ¶ù
      expect(expectedMessages.slack.text).toContain('Apple (AAPL)');
      expect(expectedMessages.slack.text).toContain('Ïã§Ï†Å Ï†ïÎ≥¥ Î≥ÄÍ≤Ω');

      // blocks ÎÇ¥Ïö© Í≤ÄÏ¶ù
      const sectionBlock = expectedMessages.slack.blocks?.find(
        (block) => block.type === 'section',
      );
      expect(sectionBlock?.text?.text).toContain('üìä EPS: 1.10 ‚Üí 1.25');
      expect(sectionBlock?.text?.text).toContain('üí∞ Îß§Ï∂ú: 480M ‚Üí 500M');
    });

    it('Î∞∞Îãπ ÏïåÎ¶º Î©îÏãúÏßÄÎ•º Ïò¨Î∞îÎ•¥Í≤å Ï≤òÎ¶¨Ìï¥Ïïº ÌïúÎã§', async () => {
      const dividendJobData = {
        ...mockJobData,
        contentType: ContentType.DIVIDEND,
        currentData: {
          dividendAmount: '0.25',
          paymentDate: '2024-12-27',
          company: { name: 'Apple', ticker: 'AAPL' },
        },
        previousData: {
          dividendAmount: '0.24',
          paymentDate: '2024-09-27',
          company: { name: 'Apple', ticker: 'AAPL' },
        },
      };

      const dividendJob = { ...mockJob, data: dividendJobData } as Job;

      // Ïã§Ï†ú Î©îÏãúÏßÄ ÎπåÎçîÎ•º Ìò∏Ï∂úÌïòÏó¨ ÏòàÏÉÅ Î©îÏãúÏßÄ ÏÉùÏÑ±
      const { buildNotificationMessages: actualBuilder } = jest.requireActual(
        '../message-builders',
      );
      const expectedMessages = actualBuilder({
        contentType: ContentType.DIVIDEND,
        notificationType: NotificationType.DATA_CHANGED,
        currentData: dividendJobData.currentData,
        previousData: dividendJobData.previousData,
        userId: 456,
      });

      // Mock ÏÑ§Ï†ï - Ïã§Ï†ú Î©îÏãúÏßÄ ÎπåÎçî Í≤∞Í≥º ÏÇ¨Ïö©
      mockBuildNotificationMessages.mockReturnValue(expectedMessages);

      mockSlackService.sendNotificationMessage.mockResolvedValue(undefined);

      // Ïã§Ìñâ
      await worker.handleSlackNotification(dividendJob);

      // Í≤ÄÏ¶ù - Ïã§Ï†ú ÏÉùÏÑ±Îêú Î©îÏãúÏßÄÍ∞Ä SlackServiceÎ°ú Ï†ÑÎã¨ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      expect(mockSlackService.sendNotificationMessage).toHaveBeenCalledWith({
        webhookUrl: 'https://hooks.slack.com/services/test/webhook',
        text: expectedMessages.slack.text,
        blocks: expectedMessages.slack.blocks,
      });

      // Î©îÏãúÏßÄ ÎÇ¥Ïö© Í≤ÄÏ¶ù
      expect(expectedMessages.slack.text).toContain('Apple (AAPL)');
      expect(expectedMessages.slack.text).toContain('Î∞∞Îãπ Ï†ïÎ≥¥ Î≥ÄÍ≤Ω');

      // blocks ÎÇ¥Ïö© Í≤ÄÏ¶ù
      const sectionBlock = expectedMessages.slack.blocks?.find(
        (block) => block.type === 'section',
      );
      expect(sectionBlock?.text?.text).toMatch(/Î∞∞ÎãπÍ∏à.*0\.24.*‚Üí.*0\.25/);
    });

    it('Í≤ΩÏ†úÏßÄÌëú ÏïåÎ¶º Î©îÏãúÏßÄÎ•º Ïò¨Î∞îÎ•¥Í≤å Ï≤òÎ¶¨Ìï¥Ïïº ÌïúÎã§', async () => {
      const indicatorJobData = {
        ...mockJobData,
        contentType: ContentType.ECONOMIC_INDICATOR,
        currentData: {
          actual: '3.2',
          previous: '3.0',
          name: 'CPI',
          country: 'USA',
        },
        previousData: {
          actual: '3.0',
          previous: '2.8',
          name: 'CPI',
          country: 'USA',
        },
      };

      const indicatorJob = { ...mockJob, data: indicatorJobData } as Job;

      // Ïã§Ï†ú Î©îÏãúÏßÄ ÎπåÎçîÎ•º Ìò∏Ï∂úÌïòÏó¨ ÏòàÏÉÅ Î©îÏãúÏßÄ ÏÉùÏÑ±
      const { buildNotificationMessages: actualBuilder } = jest.requireActual(
        '../message-builders',
      );
      const expectedMessages = actualBuilder({
        contentType: ContentType.ECONOMIC_INDICATOR,
        notificationType: NotificationType.DATA_CHANGED,
        currentData: indicatorJobData.currentData,
        previousData: indicatorJobData.previousData,
        userId: 456,
      });

      // Mock ÏÑ§Ï†ï - Ïã§Ï†ú Î©îÏãúÏßÄ ÎπåÎçî Í≤∞Í≥º ÏÇ¨Ïö©
      mockBuildNotificationMessages.mockReturnValue(expectedMessages);

      mockSlackService.sendNotificationMessage.mockResolvedValue(undefined);

      // Ïã§Ìñâ
      await worker.handleSlackNotification(indicatorJob);

      // Í≤ÄÏ¶ù - Ïã§Ï†ú ÏÉùÏÑ±Îêú Î©îÏãúÏßÄÍ∞Ä SlackServiceÎ°ú Ï†ÑÎã¨ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      expect(mockSlackService.sendNotificationMessage).toHaveBeenCalledWith({
        webhookUrl: 'https://hooks.slack.com/services/test/webhook',
        text: expectedMessages.slack.text,
        blocks: expectedMessages.slack.blocks,
      });

      // Î©îÏãúÏßÄ ÎÇ¥Ïö© Í≤ÄÏ¶ù
      expect(expectedMessages.slack.text).toContain('[USA] CPI');
      expect(expectedMessages.slack.text).toContain('Ï†ïÎ≥¥ Î≥ÄÍ≤Ω');

      // blocks ÎÇ¥Ïö© Í≤ÄÏ¶ù
      const sectionBlock = expectedMessages.slack.blocks?.find(
        (block) => block.type === 'section',
      );
      expect(sectionBlock?.text?.text).toMatch(/Ïã§Ï†ú.*3\.0.*‚Üí.*3\.2/);
    });

    it('Ï≤òÎ¶¨ ÏãúÍ∞ÑÏùÑ Ï†ïÌôïÌïòÍ≤å Ï∏°Ï†ïÌï¥Ïïº ÌïúÎã§', async () => {
      // Mock ÏÑ§Ï†ï
      mockBuildNotificationMessages.mockReturnValue({
        email: { subject: 'test', html: 'test' },
        slack: mockSlackMessage,
      });

      // Ïä¨Îûô Ï†ÑÏÜ°ÏùÑ 50ms ÏßÄÏó∞ÏãúÌÇ¥
      mockSlackService.sendNotificationMessage.mockImplementation(
        () => new Promise((resolve) => setTimeout(resolve, 50)),
      );

      const startTime = Date.now();
      await worker.handleSlackNotification(mockJob);
      const endTime = Date.now();

      // Ï≤òÎ¶¨ ÏãúÍ∞ÑÏù¥ 40ms Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï® (CI ÌôòÍ≤Ω Í≥†Î†§ÌïòÏó¨ Ïó¨Ïú† ÏûàÍ≤å ÏÑ§Ï†ï)
      const expectedMinTime = 40;
      const actualTime = endTime - startTime;
      expect(actualTime).toBeGreaterThanOrEqual(expectedMinTime);

      // updateToSentÏóê Ï†ÑÎã¨Îêú processingTime ÌôïÏù∏
      expect(mockDeliveryService.updateToSent).toHaveBeenCalledWith(
        2,
        expect.any(Number),
      );

      const processingTime = (mockDeliveryService.updateToSent as jest.Mock)
        .mock.calls[0][1];
      expect(processingTime).toBeGreaterThanOrEqual(expectedMinTime);
    });

    it('Ïó¨Îü¨ Î≤à Ïû¨ÏãúÎèÑÌïú ÌõÑ ÏµúÏ¢Ö Ïã§Ìå®Î•º Ïò¨Î∞îÎ•¥Í≤å Ï≤òÎ¶¨Ìï¥Ïïº ÌïúÎã§', async () => {
      const jobWithRetries = {
        ...mockJob,
        attemptsMade: 3, // 3Î≤àÏß∏ ÏãúÎèÑ
      } as Job;

      const testError = new Error('Persistent Slack error');

      // Ïù¥ÎØ∏ 2Î≤à Ïã§Ìå®Ìïú ÏÉÅÌÉúÎ°ú ÏÑ§Ï†ï
      mockDeliveryService.findById.mockResolvedValue({
        id: 2,
        status: 'FAILED',
        retryCount: 2, // Ïù¥ÎØ∏ 2Î≤à Ïã§Ìå®
      });

      mockBuildNotificationMessages.mockReturnValue({
        email: { subject: 'test', html: 'test' },
        slack: mockSlackMessage,
      });

      mockSlackService.sendNotificationMessage.mockRejectedValue(testError);

      // Ïã§Ìñâ Î∞è Í≤ÄÏ¶ù
      await expect(
        worker.handleSlackNotification(jobWithRetries),
      ).rejects.toThrow('Persistent Slack error');

      expect(mockDeliveryService.updateToFailed).toHaveBeenCalledWith(
        2,
        3, // 3Î≤àÏß∏ ÏãúÎèÑ Í∏∞Î°ù (2 + 1)
        testError, // Error Í∞ùÏ≤¥
        expect.any(Number),
      );
    });

    it('SlackServiceÏóêÏÑú ÏõπÌõÖ URL Í≤ÄÏ¶ù Ïã§Ìå® Ïãú Ïò¨Î∞îÎ•¥Í≤å Ï≤òÎ¶¨Ìï¥Ïïº ÌïúÎã§', async () => {
      // Mock ÏÑ§Ï†ï - SlackServiceÏóêÏÑú ÏõπÌõÖ URL Í≤ÄÏ¶ù Ïã§Ìå®Î°ú BadRequestException Î∞úÏÉù
      const validationError = new Error('ÏûÖÎ†•Ïù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');

      mockBuildNotificationMessages.mockReturnValue({
        email: { subject: 'test', html: 'test' },
        slack: mockSlackMessage,
      });

      mockSlackService.sendNotificationMessage.mockRejectedValue(
        validationError,
      );

      // Ïã§Ìñâ Î∞è Í≤ÄÏ¶ù
      await expect(worker.handleSlackNotification(mockJob)).rejects.toThrow(
        'ÏûÖÎ†•Ïù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.',
      );

      expect(mockSlackService.sendNotificationMessage).toHaveBeenCalledWith({
        webhookUrl: 'https://hooks.slack.com/services/test/webhook',
        text: mockSlackMessage.text,
      });

      expect(mockDeliveryService.updateToFailed).toHaveBeenCalledWith(
        2,
        1,
        validationError,
        expect.any(Number),
      );
    });
  });
});
