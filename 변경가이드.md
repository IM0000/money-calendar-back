아래에서는 “개별 이벤트(실적·배당·지표) 단위 구독/관심”을 완전히 없애고, 오직 “회사(Company) 단위”와 “지표 그룹(baseName+country) 단위”로만 관심(즐겨찾기)·알림 구독 기능을 제공하되, 내부적으로 해당 회사나 지표 그룹에 속한 모든 이벤트를 포함하도록 하는 최소한의 수정 방안을 제시합니다.

---

## **1. 원칙 정리**

1. **개별 이벤트 필드(earningsId, dividendId, indicatorId 등)를 없앤다.**
   - 실적(Earnings)이나 배당(Dividend), 경제지표(EconomicIndicator) 개별 ID를 직접 구독/관심할 수 있는 테이블 구조를 전부 제거합니다.
2. **회사 단위 테이블만 남겨서 → 그 회사에 속한 모든 이벤트를 처리하게 한다.**
   - SubscriptionEarnings → 이제는 “SubscriptionCompany” 역할만 수행
   - FavoriteEarnings → 이제는 “FavoriteCompany” 역할만 수행
   - (배당은 Earnings과 함께 Company 워크플로에서 묶어서 처리 가능)
3. **지표(baseName+country) 단위 테이블만 남겨서 → 그 그룹에 속한 모든 지표 이벤트를 처리하게 한다.**
   - SubscriptionIndicator → 이제는 “SubscriptionIndicatorGroup” 역할
   - FavoriteIndicator → 이제는 “FavoriteIndicatorGroup” 역할

즉, “회사 전체” 혹은 “지표 그룹 전체”를 구독/관심 등록하면, 뒤에서 해당 회사(또는 지표 그룹)에 속한 모든 이벤트 레코드를 한꺼번에 처리하도록 서비스 레이어에서 로직을 구성합니다.

---

## **2. Prisma Schema 최소 수정안**

아래처럼 **개별 이벤트용 컬럼을 전부 제거**하고, “회사 단위”·“지표 그룹 단위” 필드만 남기는 방향으로 수정합니다.

> ※ 빨간색으로 표시된 부분이 삭제/변경되는 내용입니다.

> ※ 새로 추가된 테이블은 없고, 기존 모델을 “재사용(repurpose)”하는 형태입니다.

```
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     Int                                 @id @default(autoincrement())
  email                  String                              @unique
  password               String?                             // 이메일 로그인 사용자의 경우 사용
  nickname               String?
  verified               Boolean                             @default(false)
  currentHashedRefreshToken  String?
  oauthAccounts          OAuthAccount[]
  favoriteEarnings       FavoriteEarnings[]   // << 이 모델은 나중에 삭제 or 리네임
  favoriteDividends      FavoriteDividends[]  // << 삭제 or 리네임
  favoriteIndicators     FavoriteIndicator[]  // << 삭제 or 리네임
  notificationSettings   UserNotificationSettings?
  notifications          Notification[]

-  subscriptionEarnings   SubscriptionEarnings[]
-  subscriptionIndicator  SubscriptionIndicator[]
+  subscriptionCompanies  SubscriptionCompany[]     // 새로 추가된 관계 (회사 단위 구독)
+  subscriptionIndicators SubscriptionIndicatorGroup[] // 새로 추가된 관계 (지표 그룹 단위 구독)

  createdAt              DateTime                            @default(now())
  updatedAt              DateTime                            @updatedAt
}

model UserNotificationSettings {
  id              Int      @id @default(autoincrement())
  userId          Int      @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailEnabled    Boolean  @default(false)
  slackEnabled    Boolean  @default(false)
  slackWebhookUrl String?
+  allEnabled      Boolean  @default(true)   // 모든 알림 허용/차단 (기존에 없었다면 추가)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model OAuthAccount {
  id           Int       @id @default(autoincrement())
  provider     String
  providerId   String
  oauthEmail   String?
  accessToken  String?
  refreshToken String?
  tokenExpiry  DateTime?
  userId       Int
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([provider, providerId])
}

model VerificationCode {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  code      String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model VerificationToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  email     String
  expiresAt DateTime
}

model Company {
  id          Int        @id @default(autoincrement())
  ticker      String
  name        String
  country     String
  marketValue String     @default("")
  earnings    Earnings[]
  dividends   Dividend[]
-  subscriptionEarnings SubscriptionEarnings[]
+  subscriptionCompanies SubscriptionCompany[]  // 회사 단위 구독

+  favoriteCompanies   FavoriteCompany[]    // 회사 단위 관심
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@unique([ticker, country])
}

enum ReleaseTiming {
  UNKNOWN
  PRE_MARKET
  POST_MARKET
}

model Earnings {
  id              Int      @id @default(autoincrement())
  country         String   // 국가
  releaseDate     BigInt   // 발표 날짜 (밀리초 단위)
  releaseTiming   ReleaseTiming @default(UNKNOWN)
  actualEPS       String   // 실제 EPS
  forecastEPS     String   // 예측 EPS
  previousEPS     String   // 이전 EPS
  actualRevenue   String   // 실제 매출
  forecastRevenue String   // 예측 매출
  previousRevenue String   // 이전 매출
  companyId       Int
  company         Company  @relation(fields: [companyId], references: [id])
-  favorites       FavoriteEarnings[]      // << 지워도 무방 (개별 관심 삭제)
-  subscriptionEarnings SubscriptionEarnings[] // << 지워도 무방 (개별 구독 삭제)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([releaseDate, companyId])
}

model Dividend {
  id                     Int      @id @default(autoincrement())
  country                String   // 국가
  exDividendDate         BigInt   // 배당락일 (밀리초 단위)
  dividendAmount         String   // 배당금
  previousDividendAmount String   // 이전 배당금
  paymentDate            BigInt   // 배당 지급일 (밀리초 단위)
  dividendYield          String   // 배당 수익률
  companyId              Int
  company                Company   @relation(fields: [companyId], references: [id])
-  favorites              FavoriteDividends[]  // << 지워도 무방
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  @@unique([exDividendDate, companyId])
}

model EconomicIndicator {
  id            Int      @id @default(autoincrement())
  country       String   // 국가
  releaseDate   BigInt   // 발표 날짜 (밀리초 단위)
  name          String   // 지표 이름
  baseName      String?  // 날짜 제거된 지표 이름 (e.g. "CPI", "PPI")
  importance    Int      // 중요도 (1~5)
  actual        String   // 실제 값
  forecast      String   // 예측 값
  previous      String   // 이전 값
-  favorites     FavoriteIndicator[]        // << 지워도 무방 (개별 관심 삭제)
-  subscriptionIndicator SubscriptionIndicator[] // << 지워도 무방 (개별 구독 삭제)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([releaseDate, name, country])
}

model FavoriteEarnings {
-  userId     Int
-  earningsId Int
-  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
-  earnings   Earnings @relation(fields: [earningsId], references: [id])
-
-  @@id([userId, earningsId])
+  // << 이 모델은 완전히 제거합니다. >>
}

model FavoriteDividends {
-  userId     Int
-  dividendId Int
-  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
-  dividend   Dividend @relation(fields: [dividendId], references: [id])
-
-  @@id([userId, dividendId])
+  // << 이 모델은 완전히 제거합니다. >>
}

model FavoriteIndicator {
-  userId      Int
-  indicatorId Int
-  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
-  indicator   EconomicIndicator @relation(fields: [indicatorId], references: [id])
-
-  @@id([userId, indicatorId])
+  // << 이 모델은 완전히 제거합니다. >>
}

+// ────────────────────────────────────────────────────
+// 회사 단위 관심 (FavoriteCompany)
+// ────────────────────────────────────────────────────
+model FavoriteCompany {
+  id           Int      @id @default(autoincrement())
+  userId       Int
+  companyId    Int
+  favoritedAt  DateTime @default(now())
+  isActive     Boolean  @default(true)
+
+  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
+  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
+
+  @@unique([userId, companyId])
+  @@index([companyId, isActive])
+}
+
+// ────────────────────────────────────────────────────
+// 지표 그룹 단위 관심 (FavoriteIndicatorGroup)
+// ────────────────────────────────────────────────────
+model FavoriteIndicatorGroup {
+  id           Int      @id @default(autoincrement())
+  userId       Int
+  baseName     String   // ex: "CPI", "PPI" 등
+  country      String?  // ex: "US", null이면 국가 구분 없음
+  favoritedAt  DateTime @default(now())
+  isActive     Boolean  @default(true)
+
+  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
+
+  @@unique([userId, baseName, country])
+  @@index([baseName, country, isActive])
+}
+
+// ────────────────────────────────────────────────────
+// 회사 단위 구독 (SubscriptionCompany)
+// ────────────────────────────────────────────────────
+model SubscriptionCompany {
+  id           Int      @id @default(autoincrement())
+  userId       Int
+  companyId    Int
+  subscribedAt DateTime @default(now())
+  isActive     Boolean  @default(true)
+
+  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
+  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
+
+  @@unique([userId, companyId])
+  @@index([companyId, isActive])
+}
+
+// ────────────────────────────────────────────────────
+// 지표 그룹 단위 구독 (SubscriptionIndicatorGroup)
+// ────────────────────────────────────────────────────
+model SubscriptionIndicatorGroup {
+  id           Int      @id @default(autoincrement())
+  userId       Int
+  baseName     String   // ex: "CPI", "PPI"
+  country      String?  // ex: "US", null이면 모든 국가
+  subscribedAt DateTime @default(now())
+  isActive     Boolean  @default(true)
+
+  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
+
+  @@unique([userId, baseName, country])
+  @@index([baseName, country, isActive])
+}

enum ContentType {
  EARNINGS
  DIVIDEND
  ECONOMIC_INDICATOR
}

model Notification {
  id            Int       @id @default(autoincrement())
  userId        Int
  contentType   ContentType
  contentId     Int       // 실제 이벤트 테이블(Earnings.id, Dividend.id, EconomicIndicator.id)을 가리킴
  isRead        Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  notificationDelivery NotificationDelivery[]

  @@index([userId, isRead])
  @@index([contentType, contentId])
}

model NotificationDelivery {
  id                Int       @id @default(autoincrement())
  notificationId    Int
  channelKey        NotificationChannel
  status            NotificationStatus
  errorMessage      String?
  deliveredAt       DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  notification      Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)

  @@index([notificationId])
  @@index([status])
}
```

### **변경 요약**

1. **개별 이벤트용 모델/컬럼 삭제**
   - FavoriteEarnings, FavoriteDividends, FavoriteIndicator 모델 전부 제거
   - SubscriptionEarnings 모델에서 earningsId·companyId 필드 삭제하고, 완전히 새로운 SubscriptionCompany 모델로 대체
   - SubscriptionIndicator 모델에서 indicatorId·baseName·country 필드만 남겨두고, 모델명을 SubscriptionIndicatorGroup으로 변경하여 “지표 그룹 구독” 전용으로 사용
   - Earnings, Dividend, EconomicIndicator 내부의 favorites·subscriptionEarnings·subscriptionIndicator 등 back-reference용 리스트 필드 전부 삭제
2. **회사 단위 관심/구독 테이블 추가**
   - FavoriteCompany(userId, companyId, isActive)
   - SubscriptionCompany(userId, companyId, isActive)
     → 이렇게 두 테이블만 있으면, “회사 전체 관심 등록/구독 등록”이 가능
3. **지표 그룹 단위 관심/구독 테이블 추가**
   - FavoriteIndicatorGroup(userId, baseName, country, isActive)
   - SubscriptionIndicatorGroup(userId, baseName, country, isActive)
     → “CPI US 전체 관심/구독”처럼 그룹 단위로 처리 가능
4. **전역 알림 허용/차단 필드 추가**
   - UserNotificationSettings.allEnabled Boolean @default(true)
     → 이 플래그가 false이면 서비스 로직에서 알림(Notification) 생성을 모두 무시하도록 한다.

---

## **3. 데이터 마이그레이션 전략**

- **1) 기존 구독/관심 데이터 이전**
  - SubscriptionEarnings 중 companyId가 있던 레코드
    → SubscriptionCompany로 복사 (userId, companyId, isActive 등)
  - SubscriptionIndicator 중 baseName+country가 있던 레코드
    → SubscriptionIndicatorGroup으로 복사 (userId, baseName, country, isActive)
  - **개별 이벤트 구독/관심**(earningsId나 indicatorId 보유 레코드)은 더 이상 사용하지 않으므로,
    - 완전히 삭제하거나,
    - 별도 백업 테이블에 보관 후 삭제
- **2) Prisma 마이그레이션**
  - 위 스키마를 새로 정의한 뒤, prisma migrate dev --name remove_individual_subscription_and_favorite 등을 실행
  - 마이그레이션 과정에서 기존 모델을 drop 하기 때문에, 데이터 이동 스크립트를 먼저 실행한 뒤 마이그레이션을 적용해야 한다.
- **3) 서비스 레이어 로직 수정**
  - **관심 목록 조회**

```
// 예시: 특정 유저의 ‘관심 캘린더’에 띄울 이벤트 목록
const userId = ...;

// 1) 회사 단위 관심에 속하는 모든 회사 ID를 가져온다.
const favCompanies = await prisma.favoriteCompany.findMany({
  where: { userId, isActive: true },
  select: { companyId: true },
});
const companyIds = favCompanies.map(x => x.companyId);

// 2) 그 회사 IDs에 속하는 모든 Earnings 이벤트와 Dividend 이벤트를 조회
const earningsEvents = await prisma.earnings.findMany({
  where: { companyId: { in: companyIds } },
  orderBy: { releaseDate: 'desc' },
});
const dividendEvents = await prisma.dividend.findMany({
  where: { companyId: { in: companyIds } },
  orderBy: { exDividendDate: 'desc' },
});

// 3) 지표 그룹 단위 관심
const favIndicatorGroups = await prisma.favoriteIndicatorGroup.findMany({
  where: { userId, isActive: true },
  select: { baseName: true, country: true },
});
// e.g. [{ baseName: 'CPI', country: 'US' }, …]
const indicatorsFromGroups = await prisma.economicIndicator.findMany({
  where: {
    OR: favIndicatorGroups.map(g => ({
      baseName: g.baseName,
      country: g.country,
    })),
  },
  orderBy: { releaseDate: 'desc' },
});

// 4) 최종적으로 earningsEvents, dividendEvents, indicatorsFromGroups를 합쳐서 반환
//    (필요하다면 중복 제거 로직 추가)
```

- -
  - **알림 구독 처리**

```
// 예시: 새로운 Earnings 이벤트가 들어왔을 때, 사용자에게 알림 생성
const newEarnings = /* 방금 저장된 Earnings 레코드 */;
// 1) 해당 회사 단위 구독 중인 모든 유저를 조회
const subs = await prisma.subscriptionCompany.findMany({
  where: {
    companyId: newEarnings.companyId,
    isActive: true,
  },
  select: { userId: true },
});
// 2) 각 userId에 대해 UserNotificationSettings.allEnabled 체크 후, Notification 생성
for (const { userId } of subs) {
  const settings = await prisma.userNotificationSettings.findUnique({
    where: { userId },
  });
  if (!settings || !settings.allEnabled) continue;

  await prisma.notification.create({
    data: {
      userId,
      contentType: 'EARNINGS',
      contentId: newEarnings.id,
      // isRead, createdAt, updatedAt는 자동으로 세팅됨
    },
  });
}

// 배당 이벤트가 들어올 때도 똑같은 로직으로 처리
// (companyId 기준 subscriptionCompany 조회 → notification 생성)

// 지표 이벤트가 들어올 때
const newIndicator = /* 저장된 EconomicIndicator 레코드 */;
const indicatorSubs = await prisma.subscriptionIndicatorGroup.findMany({
  where: {
    baseName: newIndicator.baseName,
    country: newIndicator.country,
    isActive: true,
  },
  select: { userId: true },
});
for (const { userId } of indicatorSubs) {
  const settings = await prisma.userNotificationSettings.findUnique({
    where: { userId },
  });
  if (!settings || !settings.allEnabled) continue;

  await prisma.notification.create({
    data: {
      userId,
      contentType: 'ECONOMIC_INDICATOR',
      contentId: newIndicator.id,
    },
  });
}
```

---

## **4. 요약 및 체크리스트**

1. **Prisma 스키마 수정**
   - SubscriptionEarnings, SubscriptionIndicator, FavoriteEarnings, FavoriteDividends, FavoriteIndicator 모델 삭제
   - 회사 단위 테이블만 남겨서 이름을 SubscriptionCompany, FavoriteCompany로 재사용
   - 지표 그룹 단위 테이블만 남겨서 이름을 SubscriptionIndicatorGroup, FavoriteIndicatorGroup로 재사용
   - UserNotificationSettings에 allEnabled 플래그 추가
2. **마이그레이션 전 데이터 백업 및 이전**
   - 기존 개별 이벤트 구독/관심(earningsId, indicatorId)을 “회사/지표 그룹 단위”로 재분류 후, 새로운 테이블로 복사
   - 데이터 이전이 끝나면 Prisma 마이그레이션으로 기존 모델 삭제
3. **서비스 레이어 수정**
   - 관심(즐겨찾기) 조회 로직 → 회사 단위와 지표 그룹 단위로 풀어서 이벤트 목록 반환
   - 알림 구독 로직 → 회사 단위와 지표 그룹 단위로 사용자 조회 후, Notification 생성
   - “allEnabled=false”인 유저는 알림 생성에서 제외
4. **프론트엔드 수정**
   - “회사/지표를 관심 추가” → /api/v1/favorite/company 혹은 /api/v1/favorite/indicator-group
   - “회사/지표를 알림 구독” → /api/v1/subscription/company 혹은 /api/v1/subscription/indicator-group
   - 기존에 개별 이벤트(earningsId, indicatorId)로 추가하던 API 호출 모두 제거

위와 같이 “개별 이벤트 구독·관심” 모델을 전부 없애고, “회사 단위”와 “지표 그룹 단위” 모델만 남긴 뒤, 서비스 레이어에서 해당 그룹에 속한 모든 이벤트를 조회해서 관심 캘린더나 알림 관리를 하도록 하면, **테이블 구조는 크게 복잡해지지 않으면서** 원하는 기능을 온전히 구현할 수 있습니다.
